#!/usr/bin/env node
import * as fs from 'fs/promises';
import * as path from 'path';
import sharp from 'sharp';

export interface ResizeOptions {
  maxSize: number;
  quality?: number;
  format?: 'jpeg' | 'png' | 'webp';
  maintainAspectRatio?: boolean;
}

/**
 * Resize an image to fit within a maximum dimension while maintaining aspect ratio
 * @param inputPath Path to input image
 * @param outputPath Path to save resized image
 * @param options Resize options
 */
export async function resizeImage(
  inputPath: string,
  outputPath: string,
  options: ResizeOptions
): Promise<{ width: number; height: number; size: number }> {
  const {
    maxSize,
    quality = 90,
    format = 'jpeg',
    maintainAspectRatio = true
  } = options;

  try {
    // Read image metadata
    const metadata = await sharp(inputPath).metadata();
    const { width = 0, height = 0 } = metadata;

    // Calculate new dimensions
    let newWidth = width;
    let newHeight = height;

    if (maintainAspectRatio) {
      // Scale down to fit within maxSize x maxSize box
      if (width > maxSize || height > maxSize) {
        const scale = Math.min(maxSize / width, maxSize / height);
        newWidth = Math.round(width * scale);
        newHeight = Math.round(height * scale);
      }
    } else {
      // Crop to exact square size
      newWidth = maxSize;
      newHeight = maxSize;
    }

    // Process image
    let pipeline = sharp(inputPath);

    if (maintainAspectRatio) {
      pipeline = pipeline.resize(newWidth, newHeight, {
        fit: 'inside',
        withoutEnlargement: true
      });
    } else {
      // Crop to square from center
      pipeline = pipeline.resize(maxSize, maxSize, {
        fit: 'cover',
        position: 'center'
      });
    }

    // Apply format and quality
    if (format === 'jpeg') {
      pipeline = pipeline.jpeg({ quality, mozjpeg: true });
    } else if (format === 'png') {
      pipeline = pipeline.png({ quality });
    } else if (format === 'webp') {
      pipeline = pipeline.webp({ quality });
    }

    // Save the resized image
    await pipeline.toFile(outputPath);

    // Get file size
    const stats = await fs.stat(outputPath);

    return {
      width: newWidth,
      height: newHeight,
      size: stats.size
    };
  } catch (error) {
    console.error(`Error resizing image ${inputPath}:`, error);
    throw error;
  }
}

/**
 * Create multiple sized versions of an image
 * @param inputPath Path to input image
 * @param outputDir Directory to save resized images
 * @param basename Base filename without extension
 * @param sizes Array of sizes to create
 */
export async function createImageSizes(
  inputPath: string,
  outputDir: string,
  basename: string,
  sizes: number[] = [512, 1024, 2048]
): Promise<Map<number, { path: string; width: number; height: number; size: number }>> {
  const results = new Map();

  // Ensure output directory exists
  await fs.mkdir(outputDir, { recursive: true });

  for (const size of sizes) {
    const outputPath = path.join(outputDir, `${basename}_${size}.jpg`);
    
    try {
      const result = await resizeImage(inputPath, outputPath, {
        maxSize: size,
        quality: 90,
        format: 'jpeg',
        maintainAspectRatio: true
      });

      results.set(size, {
        path: outputPath,
        ...result
      });

      console.log(`✅ Created ${size}px version: ${result.width}x${result.height} (${(result.size / 1024).toFixed(1)}KB)`);
    } catch (error) {
      console.error(`❌ Failed to create ${size}px version:`, error);
    }
  }

  return results;
}

/**
 * Process all images in a directory
 * @param inputDir Directory containing original images
 * @param outputDir Directory to save resized images
 * @param sizes Sizes to create for each image
 */
export async function batchResizeImages(
  inputDir: string,
  outputDir: string,
  size: number
): Promise<void> {
  const files = await fs.readdir(inputDir);
  const imageFiles = files.filter(f => /\.(jpg|jpeg|png|webp)$/i.test(f));

  console.log(`Found ${imageFiles.length} images to process`);
  console.log(`Target size: ${size}px`);
  console.log(`Output directory: ${outputDir}`);

  // Ensure output directory exists
  await fs.mkdir(outputDir, { recursive: true });

  let processed = 0;
  let failed = 0;

  for (const file of imageFiles) {
    const inputPath = path.join(inputDir, file);
    const outputPath = path.join(outputDir, file);

    console.log(`\nProcessing: ${file}`);

    try {
      const result = await resizeImage(inputPath, outputPath, {
        maxSize: size,
        quality: 90,
        format: 'jpeg',
        maintainAspectRatio: true
      });
      console.log(`✅ Resized to ${result.width}x${result.height} (${(result.size / 1024).toFixed(1)}KB)`);
      processed++;
    } catch (error) {
      console.error(`❌ Failed to process ${file}:`, error);
      failed++;
    }
  }

  console.log(`\n✅ Processed: ${processed}`);
  console.log(`❌ Failed: ${failed}`);
}

// CLI interface
async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    console.log(`
Image Resizing Utility
=====================

Usage:
  # Resize a single image
  npx tsx scripts/resize-images.ts --input=path/to/image.jpg --output=path/to/output.jpg --size=1024

  # Batch process directory to single size
  npx tsx scripts/resize-images.ts --input-dir=data/images/original --output-dir=data/images/512 --size=512
  npx tsx scripts/resize-images.ts --input-dir=data/images/original --output-dir=data/images/2048 --size=2048

  # Create multiple sizes from single image (legacy)
  npx tsx scripts/resize-images.ts --input=path/to/image.jpg --output-dir=path/to/output/ --sizes=512,1024,2048

Options:
  --input         Path to single image
  --input-dir     Directory of images to process
  --output        Output path for single image
  --output-dir    Output directory
  --size          Target size in pixels (default: 1024)
  --sizes         Comma-separated sizes for multi-size output (legacy)
  --quality       JPEG quality 1-100 (default: 90)
  --square        Crop to square (default: false, maintains aspect ratio)
`);
    return;
  }

  // Parse arguments
  const getArg = (name: string): string | undefined => {
    const arg = args.find(a => a.startsWith(`--${name}=`));
    return arg ? arg.split('=')[1] : undefined;
  };

  const input = getArg('input');
  const inputDir = getArg('input-dir');
  const output = getArg('output');
  const outputDir = getArg('output-dir');
  const size = getArg('size') ? parseInt(getArg('size')!) : 1024;
  const sizes = getArg('sizes') ? getArg('sizes')!.split(',').map(s => parseInt(s)) : [512, 1024];
  const quality = getArg('quality') ? parseInt(getArg('quality')!) : 90;
  const square = args.includes('--square');

  try {
    if (inputDir && outputDir) {
      // Batch process with single size
      await batchResizeImages(inputDir, outputDir, size);
    } else if (input && output && !outputDir) {
      // Single image, single size
      const result = await resizeImage(input, output, {
        maxSize: size,
        quality,
        maintainAspectRatio: !square
      });
      console.log(`✅ Resized to ${result.width}x${result.height} (${(result.size / 1024).toFixed(1)}KB)`);
    } else if (input && outputDir) {
      // Single image, multiple sizes
      const basename = path.basename(input, path.extname(input));
      await createImageSizes(input, outputDir, basename, sizes);
    } else {
      console.error('Invalid arguments. Run without arguments to see usage.');
      process.exit(1);
    }
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main().catch(console.error);
}

// Export for use in other scripts
export { sharp };